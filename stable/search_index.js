var documenterSearchIndex = {"docs":
[{"location":"#BigRiverJunbi","page":"Home","title":"BigRiverJunbi","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BigRiverJunbi.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#BigRiverJunbi.check_mad-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.check_mad","text":"check_mad(mat::Matrix{T}; dims::Int = 2) where {T <: Real}\n\nChecks if the MAD (median absolute deviation) is zero for each column of a matrix. If it is, then errors and displays the list of columns with zero MAD.\n\nArguments\n\nmat::Matrix{T}: The matrix to check the MAD for.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.check_mad-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.check_mad","text":"check_mad(x::Vector{T}) where {T <: Real}\n\nChecks if the MAD (median absolute deviation) is zero for a vector. If it is, then errors.\n\nArguments\n\nx::Vector{T}: The vector to check the MAD for.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.huberize-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.huberize","text":"huberize(mat::Matrix{T}; alpha::Float64 = 1.0,\n    error_on_zero_mad::Bool = true) where {T <: Real}\n\nPerforms Huberization for sample intensities.\n\nArguments\n\nmat: The matrix to normalize.\nalpha: The alpha parameter for Huberization. Default is 1.0.\nerror_on_zero_mad: Whether to throw an error if the MAD is zero. Default is true.\n\nwarning: Warning\nIf you set error_on_zero_mad to false, this function will return a result with NaN values if the MAD is zero. This can be useful if you are expecting this behavior and want to handle it yourself, but should be used with caution.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n              7 3 5 1.5 4.5;\n              8 2 7 6 9]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  1.5  4.5\n 8.0  2.0  7.0  6.0  9.0\n\njulia> BigRiverJunbi.huberize(mat)\n3×5 Matrix{Float64}:\n 2.86772  1.0  2.0002  3.0      3.5\n 7.0      3.0  5.0     1.5      4.5\n 8.0      2.0  7.0     5.89787  7.83846\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.huberize-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.huberize","text":"huberize(x::Vector{T}; alpha::Float64 = 1.0,\n    error_on_zero_mad::Bool = true) where {T <: Real}\n\nPerforms Huberization for a single vector.\n\nArguments\n\nx: The vector to Huberize.\nalpha: The alpha parameter for the Huberization. Default is 1.0.\nerror_on_zero_mad: Whether to throw an error if the MAD is zero. Default is true.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.huberloss-Tuple{Real}","page":"Home","title":"BigRiverJunbi.huberloss","text":"huberloss(x::Real; alpha::Float64 = 1.0)\n\nComputes the Huber loss for a given value. This is defined as:\n\nL(x) = begincases\n    frac12x^2  textif  x leq alpha \n    alpha (x - fracalpha^22)  textif  x  alpha\nendcases\n\nArguments\n\nx: The value to compute the Huber loss for.\nalpha: The alpha parameter for the Huber loss. Default is 1.0.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.imputeKNN!-Union{Tuple{M}, Tuple{AbstractMatrix{Union{Missing, Float64}}, Int64, Float64, Union{Nothing, Int64}, M}} where M<:Distances.UnionMinkowskiMetric","page":"Home","title":"BigRiverJunbi.imputeKNN!","text":"imputeKNN!(\n    data::AbstractMatrix{Union{Missing, Float64}},\n    k::Int,\n    threshold::Float64,\n    dims::Union{Nothing, Int},\n    distance::M\n) where {M <: NearestNeighbors.MinkowskiMetric}\n\nReplaces missing elements based on k-nearest neighbors (KNN) imputation. Modifies the original matrix in place. This method is almost an exact copy of the KNN imputation method from Impute.jl.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\nk: number of nearest neighbors to use for imputation.\nthreshold: threshold for the number of missing neighbors.\ndims: dimension along which the statistic is calculated.\ndistance: distance metric to use for the nearest neighbors search, taken from Distances.jl. Default is Euclidean(). This can only be one of the Minkowski metrics i.e. Euclidean, Cityblock, Minkowski and Chebyshev.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.imputeKNN-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.imputeKNN","text":"imputeKNN(df::DataFrame; k = 5, threshold = 0.2, start_col = 1)\n\nReplaces missing elements based on k-nearest neighbors (KNN) imputation.\n\nArguments\n\ndf: dataframe with missing values.\nk: number of nearest neighbors to use for imputation.\nthreshold: threshold for the number of missing neighbors.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_QRILC-Tuple{Matrix{Union{Missing, Float64}}}","page":"Home","title":"BigRiverJunbi.impute_QRILC","text":"impute_QRILC(\n    data::Matrix{Union{Missing, Float64}};\n    tune_sigma::Float64 = 1.0,\n    eps::Float64 = 0.005\n)\n\nReturns imputated matrix based on the \"Quantile regression Imputation for left-censored data\" (QRILC) method. The function is based on the function impute.QRILC from the imputeLCMD.R package, with one difference: the default value of eps is set to 0.005 instead of 0.001.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\ntune_sigma: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 < tune_sigma < 1 if the complete data distribution is supposed to be                 left-censored. Default is 1.0.\neps: small value added to the quantile for stability.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_cat!-Tuple{Matrix{Union{Missing, Float64}}}","page":"Home","title":"BigRiverJunbi.impute_cat!","text":"impute_cat!(data::Matrix{Union{Missing, Float64}})\n\nImputes missing elements based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median Modifies the original matrix in place.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_cat-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.impute_cat","text":"impute_cat(df_missing::DataFrame; start_col::Int64 = 1)\n\nReturns imputated dataframe based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median\n\nArguments\n\ndf_missing: dataframe with missing values.\nstart_col: column index to start imputing from.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing\n   2 │     2  missing        4  missing  missing\n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.impute_cat(df)\n3×5 DataFrame\n Row │ A         B         C         D         E\n     │ Float64?  Float64?  Float64?  Float64?  Float64?\n─────┼──────────────────────────────────────────────────\n   1 │      1.0       0.0       0.0       1.0       0.0\n   2 │      2.0       0.0       1.0       0.0       0.0\n   3 │      2.0       0.0       2.0       2.0       2.0\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_cat-Tuple{Matrix{Union{Missing, Float64}}}","page":"Home","title":"BigRiverJunbi.impute_cat","text":"impute_cat(data::Matrix{Union{Missing, Float64}})\n\nImputes missing elements based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median Returns a new matrix without modifying the original matrix.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_half_min-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.impute_half_min","text":"impute_half_min(df::DataFrame; start_col::Int64 = 1)\n\nReplaces missing elements in the specified columns with half of the minimum of non-missing elements in the corresponding variable.\n\nArguments\n\ndf: dataframe with missing values.\nstart_col: column index to start imputing from.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing\n   2 │     2  missing        4  missing  missing\n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.impute_half_min(df)\n3×5 DataFrame\n Row │ A         B         C         D         E\n     │ Float64?  Float64?  Float64?  Float64?  Float64?\n─────┼──────────────────────────────────────────────────\n   1 │      1.0       0.5       0.5       6.0       0.5\n   2 │      2.0       1.0       4.0       1.0       1.0\n   3 │      3.0       1.5       5.0       7.0      10.0\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_min-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.impute_min","text":"impute_min(df::DataFrame; start_col::Int64 = 1)\n\nReplaces missing elements in the specified columns with the minimum of non-missing elements in the corresponding variable.\n\nArguments\n\ndf: dataframe with missing values.\nstart_col: column index to start imputing from.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing \n   2 │     2  missing        4  missing  missing \n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.impute_min(df)\n3×5 DataFrame\n Row │ A         B         C         D         E\n     │ Float64?  Float64?  Float64?  Float64?  Float64? \n─────┼──────────────────────────────────────────────────\n   1 │      1.0       1.0       1.0       6.0       1.0\n   2 │      2.0       2.0       4.0       2.0       2.0\n   3 │      3.0       3.0       5.0       7.0      10.0\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_min_prob","page":"Home","title":"BigRiverJunbi.impute_min_prob","text":"impute_min_prob(data::Matrix{Union{Missing, Float64}}, q = 0.01; tune_sigma = 1)\n\nReplaces missing values with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations. Returns a new matrix without modifying the original matrix.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\nq: quantile of the minimum values to use for imputation. Default is 0.01.\ntune_sigma: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 < tune_sigma < 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#BigRiverJunbi.impute_min_prob!","page":"Home","title":"BigRiverJunbi.impute_min_prob!","text":"impute_min_prob!(data::Matrix{Union{Missing, Float64}}, q = 0.01; tune_sigma = 1)\n\nReplaces missing values with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations. Modifies the original matrix in place.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\nq: quantile of the minimum values to use for imputation. Default is 0.01.\ntune_sigma: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 < tune_sigma < 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.\n\n\n\n\n\n","category":"function"},{"location":"#BigRiverJunbi.impute_min_prob-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.impute_min_prob","text":"impute_min_prob(df::DataFrame; start_col::Int64 = 1, q = 0.01; tune_sigma = 1)\n\nReplaces missing values in the specified columns with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations.\n\nArguments\n\ndf: dataframe with missing values.\nstart_col: column index to start imputing from.\nq: quantile of the minimum values to use for imputation. Default is 0.01.\ntune_sigma: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 < tune_sigma < 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_zero!-Tuple{Matrix{Union{Missing, Float64}}}","page":"Home","title":"BigRiverJunbi.impute_zero!","text":"impute_zero!(data::Matrix{Union{Missing, Float64}})\n\nModifies the original matrix in place to replace missing elements with zero.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_zero-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.impute_zero","text":"impute_zero(df::DataFrame; start_col::Int64 = 1)\n\nReplaces missing elements in the specified columns with zero.\n\nArguments\n\ndf: dataframe with missing values.\nstart_col: column index to start imputing from.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing\n   2 │     2  missing        4  missing  missing\n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.impute_zero(df)\n3×5 DataFrame\n Row │ A         B         C         D         E\n     │ Float64?  Float64?  Float64?  Float64?  Float64?\n─────┼──────────────────────────────────────────────────\n   1 │      1.0       0.0       0.0       6.0       0.0\n   2 │      2.0       0.0       4.0       0.0       0.0\n   3 │      3.0       0.0       5.0       7.0      10.0\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.impute_zero-Tuple{Matrix{Union{Missing, Float64}}}","page":"Home","title":"BigRiverJunbi.impute_zero","text":"impute_zero(data::Matrix{Union{Missing, Float64}})\n\nReturns a matrix with missing elements replaced with zero without modifying the original matrix.\n\nArguments\n\ndata: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples       and the columns are the features.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.intnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.intnorm","text":"intnorm(mat::Matrix{T}; dims::Int64 = 2, lambda::Float64 = 1.0) where T <: Real\n\nTotal Area Normalization for each row or column. By default, it normalizes each row. This requires that the matrix has all positive values.\n\nArguments\n\nmat: The matrix to normalize.\ndims: The dimension to normalize across. Default is 2.\nlambda: The lambda parameter for the normalization. Default is 1.0.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n              7 3 5 1.5 4.5;\n              8 2 7 6 9]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  1.5  4.5\n 8.0  2.0  7.0  6.0  9.0\n\njulia> BigRiverJunbi.intnorm(mat)\n3×5 Matrix{Float64}:\n 0.05      0.1       0.2       0.3        0.35\n 0.333333  0.142857  0.238095  0.0714286  0.214286\n 0.25      0.0625    0.21875   0.1875     0.28125\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.log2_tx-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.log2_tx","text":"log2_tx(mat::Matrix{Float64}; eps::Float64 = 1.0)\n\nComputes logarithm base 2 on a matrix, adding a constant to all values to avoid log(0). This requires that the matrix has all positive values.\n\nArguments\n\nmat: The matrix to transform.\neps: The constant to add to all values. Default is 1.0.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n             7 3 5 0 3.5;\n             8 2 5 6 0]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  0.0  3.5\n 8.0  2.0  5.0  6.0  0.0\n\njulia> BigRiverJunbi.log2_tx(mat)\n3×5 Matrix{Float64}:\n 0.584963  1.0      1.58496  2.0      2.16993\n 3.0       2.0      2.58496  0.0      2.16993\n 3.16993   1.58496  2.58496  2.80735  0.0\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.meancenter_tx-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Int64}} where T<:Real","page":"Home","title":"BigRiverJunbi.meancenter_tx","text":"meancenter_tx(mat::Matrix{Float64}, dims::Int64 = 1)\n\nMean center a matrix across the specified dimension. This requires that the matrix has all positive values.\n\nArguments\n\nmat: The matrix to transform.\ndims: The dimension to mean center across. Default is 1.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n             7 3 5 0 3.5;\n             8 2 5 6 0]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  0.0  3.5\n 8.0  2.0  5.0  6.0  0.0\n\njulia> BigRiverJunbi.meancenter_tx(mat)\n3×5 Matrix{Float64}:\n -4.66667  -1.0  -2.0   0.0   1.16667\n  1.83333   1.0   1.0  -3.0   1.16667\n  2.83333   0.0   1.0   3.0  -2.33333\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.missing_percentages-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.missing_percentages","text":"missing_percentages(df::DataFrame)\n\nReturns the percentage of missing values in each column and row, as well as the total percentage of missing values in the dataframe.\n\nArguments\n\ndf::DataFrame: The dataframe to calculate the missing percentages for.\n\nReturns\n\npmissing_cols::Vector{Float64}: The percentage of missing values in each column.\npmissing_rows::Vector{Float64}: The percentage of missing values in each row.\ntotal_missing::Float64: The total percentage of missing values in the dataframe.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing\n   2 │     2  missing        4  missing  missing\n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.missing_percentages(df)\n([0.0, 1.0, 0.3333333333333333, 0.3333333333333333, 0.6666666666666666], [0.6, 0.6, 0.2], 0.4666666666666667)\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.missing_summary-Tuple{DataFrames.DataFrame}","page":"Home","title":"BigRiverJunbi.missing_summary","text":"missing_summary(df::DataFrame)\n\nAdds a row and column to the dataframe that contains the percentage of missing values in each column and row. Returns a pretty table with the percentage of missing values in the last row and column highlighted.\n\nwarning: Warning\nThis function will not preserve the type of the dataframe, as it converts everything to a string for the pretty table. It is primarily used for quick visualizations. For getting the actual missing percentages, use the missing_percentages function instead.\n\nArguments\n\ndf::DataFrame: The dataframe to add the missing summary to.\n\nExamples\n\njulia> df = DataFrame(A = [1, 2, 3],\n                 B = [missing, missing, missing],\n                 C = [missing, 4, 5],\n                 D = [6, missing, 7],\n                 E = [missing, missing, 10])\n3×5 DataFrame\n Row │ A      B        C        D        E\n     │ Int64  Missing  Int64?   Int64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │     1  missing  missing        6  missing\n   2 │     2  missing        4  missing  missing\n   3 │     3  missing        5        7       10\n\njulia> BigRiverJunbi.missing_summary(df)\n┌───────────────┬────────┬─────────┬─────────┬─────────┬─────────┬───────────────┐\n│               │      A │       B │       C │       D │       E │ pmissing_rows │\n│               │ String │  String │  String │  String │  String │        String │\n├───────────────┼────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤\n│             1 │      1 │ missing │ missing │       6 │ missing │           0.6 │\n│             2 │      2 │ missing │       4 │ missing │ missing │           0.6 │\n│             3 │      3 │ missing │       5 │       7 │      10 │           0.2 │\n├───────────────┼────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤\n│ pmissing_cols │    0.0 │     1.0 │    0.33 │    0.33 │    0.67 │          0.47 │\n└───────────────┴────────┴─────────┴─────────┴─────────┴─────────┴───────────────┘\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.pqnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.pqnorm","text":"pqnorm(mat::Matrix{Float64})\n\nPerforms a probabilistic quotient normalization (PQN) for sample intensities. This assumes that the matrix is organized as samples x features and requires that the matrix have all positive values.\n\nArguments\n\nmat: The matrix to normalize.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n              7 3 5 1.5 4.5;\n              8 2 7 6 9]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  1.5  4.5\n 8.0  2.0  7.0  6.0  9.0\n\njulia> BigRiverJunbi.pqnorm(mat)\n3×5 Matrix{Float64}:\n 0.05     0.1      0.2      0.3       0.35\n 0.30625  0.13125  0.21875  0.065625  0.196875\n 0.25     0.0625   0.21875  0.1875    0.28125\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.quantilenorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"BigRiverJunbi.quantilenorm","text":"quantilenorm(data::Matrix{T}) where T <: Real\n\nPerforms quantile normalization for sample intensities. This assumes that the matrix is organized as samples x features.\n\nArguments\n\ndata: The matrix to normalize.\n\nExamples\n\njulia> mat = [0.5 1 2 3 3.5;\n              7 3 5 1.5 4.5;\n              8 2 7 6 9]\n3×5 Matrix{Float64}:\n 0.5  1.0  2.0  3.0  3.5\n 7.0  3.0  5.0  1.5  4.5\n 8.0  2.0  7.0  6.0  9.0\n\njulia> BigRiverJunbi.quantilenorm(mat)\n3×5 Matrix{Float64}:\n 1.7  1.7  1.7  4.3  1.7\n 4.3  6.6  4.3  1.7  4.3\n 6.6  4.3  6.6  6.6  6.6\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.substitute!-Tuple{AbstractArray{Union{Missing, Float64}}, Function}","page":"Home","title":"BigRiverJunbi.substitute!","text":"substitute!(\n    data::AbstractArray{Union{Missing, Float64}},\n    statistic::Function;\n    dims::Union{Nothing, Int} = nothing\n)\n\nSubstitutes missing values with the value calculated by the statistic function along the specified dimension and modifies the original array in place.\n\nArguments\n\ndata: array of values. One example: matrix of metabolomics data, where the rows are the features and the columns are the samples.\nstatistic: function that calculates the value to substitute the missing values.\ndims: dimension along which the statistic is calculated.\n\n\n\n\n\n","category":"method"},{"location":"#BigRiverJunbi.substitute-Tuple{AbstractArray{Union{Missing, Float64}}, Function}","page":"Home","title":"BigRiverJunbi.substitute","text":"substitute(\n    data::AbstractArray{Union{Missing, Float64}},\n    statistic::Function;\n    dims::Union{Nothing, Int} = nothing\n)\n\nSubstitutes missing values with the value calculated by the statistic function along the specified dimension and returns a new array without modifying the original array.\n\nArguments\n\ndata: array of values. One example: matrix of metabolomics data, where the rows are the features and the columns are the samples.\nstatistic: function that calculates the value to substitute the missing values.\ndims: dimension along which the statistic is calculated.\n\n\n\n\n\n","category":"method"}]
}
