<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · BigRiverJunbi.jl</title><meta name="title" content="Home · BigRiverJunbi.jl"/><meta property="og:title" content="Home · BigRiverJunbi.jl"/><meta property="twitter:title" content="Home · BigRiverJunbi.jl"/><meta name="description" content="Documentation for BigRiverJunbi.jl."/><meta property="og:description" content="Documentation for BigRiverJunbi.jl."/><meta property="twitter:description" content="Documentation for BigRiverJunbi.jl."/><meta property="og:url" content="https://senresearch.github.io/BigRiverJunbi.jl/"/><meta property="twitter:url" content="https://senresearch.github.io/BigRiverJunbi.jl/"/><link rel="canonical" href="https://senresearch.github.io/BigRiverJunbi.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>BigRiverJunbi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/senresearch/BigRiverJunbi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="BigRiverJunbi"><a class="docs-heading-anchor" href="#BigRiverJunbi">BigRiverJunbi</a><a id="BigRiverJunbi-1"></a><a class="docs-heading-anchor-permalink" href="#BigRiverJunbi" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/theabhirath/BigRiverJunbi.jl">BigRiverJunbi</a>.</p><ul><li><a href="#BigRiverJunbi.check_mad-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.check_mad</code></a></li><li><a href="#BigRiverJunbi.check_mad-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.check_mad</code></a></li><li><a href="#BigRiverJunbi.huberize-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.huberize</code></a></li><li><a href="#BigRiverJunbi.huberize-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.huberize</code></a></li><li><a href="#BigRiverJunbi.huberloss-Tuple{Real}"><code>BigRiverJunbi.huberloss</code></a></li><li><a href="#BigRiverJunbi.imputeKNN-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.imputeKNN</code></a></li><li><a href="#BigRiverJunbi.imputeKNN!-Union{Tuple{M}, Tuple{AbstractMatrix{Union{Missing, Float64}}, Int64, Float64, Union{Nothing, Int64}, M}} where M&lt;:Distances.UnionMinkowskiMetric"><code>BigRiverJunbi.imputeKNN!</code></a></li><li><a href="#BigRiverJunbi.impute_QRILC-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_QRILC</code></a></li><li><a href="#BigRiverJunbi.impute_cat-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_cat</code></a></li><li><a href="#BigRiverJunbi.impute_cat-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_cat</code></a></li><li><a href="#BigRiverJunbi.impute_cat!-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_cat!</code></a></li><li><a href="#BigRiverJunbi.impute_half_min-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_half_min</code></a></li><li><a href="#BigRiverJunbi.impute_min-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_min</code></a></li><li><a href="#BigRiverJunbi.impute_min_prob"><code>BigRiverJunbi.impute_min_prob</code></a></li><li><a href="#BigRiverJunbi.impute_min_prob-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_min_prob</code></a></li><li><a href="#BigRiverJunbi.impute_min_prob!"><code>BigRiverJunbi.impute_min_prob!</code></a></li><li><a href="#BigRiverJunbi.impute_zero-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_zero</code></a></li><li><a href="#BigRiverJunbi.impute_zero-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_zero</code></a></li><li><a href="#BigRiverJunbi.impute_zero!-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_zero!</code></a></li><li><a href="#BigRiverJunbi.intnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.intnorm</code></a></li><li><a href="#BigRiverJunbi.log2_tx-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.log2_tx</code></a></li><li><a href="#BigRiverJunbi.meancenter_tx-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:Real"><code>BigRiverJunbi.meancenter_tx</code></a></li><li><a href="#BigRiverJunbi.missing_percentages-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.missing_percentages</code></a></li><li><a href="#BigRiverJunbi.missing_summary-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.missing_summary</code></a></li><li><a href="#BigRiverJunbi.pqnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.pqnorm</code></a></li><li><a href="#BigRiverJunbi.quantilenorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.quantilenorm</code></a></li><li><a href="#BigRiverJunbi.substitute-Tuple{AbstractArray{Union{Missing, Float64}}, Function}"><code>BigRiverJunbi.substitute</code></a></li><li><a href="#BigRiverJunbi.substitute!-Tuple{AbstractArray{Union{Missing, Float64}}, Function}"><code>BigRiverJunbi.substitute!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.check_mad-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.check_mad-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.check_mad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_mad(mat::Matrix{T}; dims::Int = 2) where {T &lt;: Real}</code></pre><p>Checks if the MAD (median absolute deviation) is zero for each column of a matrix. If it is, then errors and displays the list of columns with zero MAD.</p><p><strong>Arguments</strong></p><ul><li><code>mat::Matrix{T}</code>: The matrix to check the MAD for.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/utils.jl#L120-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.check_mad-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.check_mad-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.check_mad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_mad(x::Vector{T}) where {T &lt;: Real}</code></pre><p>Checks if the MAD (median absolute deviation) is zero for a vector. If it is, then errors.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{T}</code>: The vector to check the MAD for.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/utils.jl#L147-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.huberize-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.huberize-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.huberize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">huberize(mat::Matrix{T}; alpha::Float64 = 1.0,
    error_on_zero_mad::Bool = true) where {T &lt;: Real}</code></pre><p>Performs Huberization for sample intensities.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: The matrix to normalize.</li><li><code>alpha</code>: The alpha parameter for Huberization. Default is 1.0.</li><li><code>error_on_zero_mad</code>: Whether to throw an error if the MAD is zero. Default is <code>true</code>.</li></ul><div class="admonition is-warning" id="Warning-d31fbb71cdc5ec82"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-d31fbb71cdc5ec82" title="Permalink"></a></header><div class="admonition-body"><p>If you set <code>error_on_zero_mad</code> to <code>false</code>, this function will return a result with NaN values if the MAD is zero. This can be useful if you are expecting this behavior and want to handle it yourself, but should be used with caution.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
              7 3 5 1.5 4.5;
              8 2 7 6 9]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  1.5  4.5
 8.0  2.0  7.0  6.0  9.0

julia&gt; BigRiverJunbi.huberize(mat)
3×5 Matrix{Float64}:
 2.86772  1.0  2.0002  3.0      3.5
 7.0      3.0  5.0     1.5      4.5
 8.0      2.0  7.0     5.89787  7.83846</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L125-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.huberize-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.huberize-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.huberize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">huberize(x::Vector{T}; alpha::Float64 = 1.0,
    error_on_zero_mad::Bool = true) where {T &lt;: Real}</code></pre><p>Performs Huberization for a single vector.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The vector to Huberize.</li><li><code>alpha</code>: The alpha parameter for the Huberization. Default is 1.0.</li><li><code>error_on_zero_mad</code>: Whether to throw an error if the MAD is zero. Default is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L170-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.huberloss-Tuple{Real}" href="#BigRiverJunbi.huberloss-Tuple{Real}"><code>BigRiverJunbi.huberloss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">huberloss(x::Real; alpha::Float64 = 1.0)</code></pre><p>Computes the Huber loss for a given value. This is defined as:</p><p class="math-container">\[L(x) = \begin{cases}
    \frac{1}{2}x^2 &amp; \text{if } |x| \leq \alpha \\
    \alpha (|x| - \frac{\alpha^2}{2}) &amp; \text{if } |x| &gt; \alpha
\end{cases}\]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The value to compute the Huber loss for.</li><li><code>alpha</code>: The alpha parameter for the Huber loss. Default is 1.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L192-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.imputeKNN!-Union{Tuple{M}, Tuple{AbstractMatrix{Union{Missing, Float64}}, Int64, Float64, Union{Nothing, Int64}, M}} where M&lt;:Distances.UnionMinkowskiMetric" href="#BigRiverJunbi.imputeKNN!-Union{Tuple{M}, Tuple{AbstractMatrix{Union{Missing, Float64}}, Int64, Float64, Union{Nothing, Int64}, M}} where M&lt;:Distances.UnionMinkowskiMetric"><code>BigRiverJunbi.imputeKNN!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imputeKNN!(
    data::AbstractMatrix{Union{Missing, Float64}},
    k::Int,
    threshold::Float64,
    dims::Union{Nothing, Int},
    distance::M
) where {M &lt;: NearestNeighbors.MinkowskiMetric}</code></pre><p>Replaces missing elements based on k-nearest neighbors (KNN) imputation. Modifies the original matrix in place. This method is almost an exact copy of the KNN imputation method from <a href="https://github.com/invenia/Impute.jl">Impute.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li><li><code>k</code>: number of nearest neighbors to use for imputation.</li><li><code>threshold</code>: threshold for the number of missing neighbors.</li><li><code>dims</code>: dimension along which the statistic is calculated.</li><li><code>distance</code>: distance metric to use for the nearest neighbors search, taken from Distances.jl. Default is <code>Euclidean()</code>. This can only be one of the Minkowski metrics i.e. Euclidean, Cityblock, Minkowski and Chebyshev.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L461-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.imputeKNN-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.imputeKNN-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.imputeKNN</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imputeKNN(df::DataFrame; k = 5, threshold = 0.2, start_col = 1)</code></pre><p>Replaces missing elements based on k-nearest neighbors (KNN) imputation.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: dataframe with missing values.</li><li><code>k</code>: number of nearest neighbors to use for imputation.</li><li><code>threshold</code>: threshold for the number of missing neighbors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L537-L547">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_QRILC-Tuple{Matrix{Union{Missing, Float64}}}" href="#BigRiverJunbi.impute_QRILC-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_QRILC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_QRILC(
    data::Matrix{Union{Missing, Float64}};
    tune_sigma::Float64 = 1.0,
    eps::Float64 = 0.005
)</code></pre><p>Returns imputated matrix based on the &quot;Quantile regression Imputation for left-censored data&quot; (QRILC) method. The function is based on the function <code>impute.QRILC</code> from the <code>imputeLCMD.R</code> package, with one difference: the default value of <code>eps</code> is set to 0.005 instead of 0.001.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li><li><code>tune_sigma</code>: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 &lt; tune_sigma &lt; 1 if the complete data distribution is supposed to be                 left-censored. Default is 1.0.</li><li><code>eps</code>: small value added to the quantile for stability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L577-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_cat!-Tuple{Matrix{Union{Missing, Float64}}}" href="#BigRiverJunbi.impute_cat!-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_cat!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_cat!(data::Matrix{Union{Missing, Float64}})</code></pre><p>Imputes missing elements based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median Modifies the original matrix in place.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L387-L400">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_cat-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.impute_cat-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_cat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_cat(df_missing::DataFrame; start_col::Int64 = 1)</code></pre><p>Returns imputated dataframe based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median</p><p><strong>Arguments</strong></p><ul><li><code>df_missing</code>: dataframe with missing values.</li><li><code>start_col</code>: column index to start imputing from.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing
   2 │     2  missing        4  missing  missing
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.impute_cat(df)
3×5 DataFrame
 Row │ A         B         C         D         E
     │ Float64?  Float64?  Float64?  Float64?  Float64?
─────┼──────────────────────────────────────────────────
   1 │      1.0       0.0       0.0       1.0       0.0
   2 │      2.0       0.0       1.0       0.0       0.0
   3 │      2.0       0.0       2.0       2.0       2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L326-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_cat-Tuple{Matrix{Union{Missing, Float64}}}" href="#BigRiverJunbi.impute_cat-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_cat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_cat(data::Matrix{Union{Missing, Float64}})</code></pre><p>Imputes missing elements based on a categorical imputation:     - 0: Missing values     - 1: Values below the median     - 2: Values equal to or above the median Returns a new matrix without modifying the original matrix.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L371-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_half_min-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.impute_half_min-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_half_min</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_half_min(df::DataFrame; start_col::Int64 = 1)</code></pre><p>Replaces missing elements in the specified columns with half of the minimum of non-missing elements in the corresponding variable.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: dataframe with missing values.</li><li><code>start_col</code>: column index to start imputing from.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing
   2 │     2  missing        4  missing  missing
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.impute_half_min(df)
3×5 DataFrame
 Row │ A         B         C         D         E
     │ Float64?  Float64?  Float64?  Float64?  Float64?
─────┼──────────────────────────────────────────────────
   1 │      1.0       0.5       0.5       6.0       0.5
   2 │      2.0       1.0       4.0       1.0       1.0
   3 │      3.0       1.5       5.0       7.0      10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L279-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_min-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.impute_min-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_min</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_min(df::DataFrame; start_col::Int64 = 1)</code></pre><p>Replaces missing elements in the specified columns with the minimum of non-missing elements in the corresponding variable.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: dataframe with missing values.</li><li><code>start_col</code>: column index to start imputing from.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing 
   2 │     2  missing        4  missing  missing 
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.impute_min(df)
3×5 DataFrame
 Row │ A         B         C         D         E
     │ Float64?  Float64?  Float64?  Float64?  Float64? 
─────┼──────────────────────────────────────────────────
   1 │      1.0       1.0       1.0       6.0       1.0
   2 │      2.0       2.0       4.0       2.0       2.0
   3 │      3.0       3.0       5.0       7.0      10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L143-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_min_prob" href="#BigRiverJunbi.impute_min_prob"><code>BigRiverJunbi.impute_min_prob</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_min_prob(data::Matrix{Union{Missing, Float64}}, q = 0.01; tune_sigma = 1)</code></pre><p>Replaces missing values with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations. Returns a new matrix without modifying the original matrix.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li><li><code>q</code>: quantile of the minimum values to use for imputation. Default is 0.01.</li><li><code>tune_sigma</code>: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 &lt; tune_sigma &lt; 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L212-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_min_prob!" href="#BigRiverJunbi.impute_min_prob!"><code>BigRiverJunbi.impute_min_prob!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_min_prob!(data::Matrix{Union{Missing, Float64}}, q = 0.01; tune_sigma = 1)</code></pre><p>Replaces missing values with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations. Modifies the original matrix in place.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li><li><code>q</code>: quantile of the minimum values to use for imputation. Default is 0.01.</li><li><code>tune_sigma</code>: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 &lt; tune_sigma &lt; 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L235-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_min_prob-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.impute_min_prob-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_min_prob</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_min_prob(df::DataFrame; start_col::Int64 = 1, q = 0.01; tune_sigma = 1)</code></pre><p>Replaces missing values in the specified columns with random draws from a gaussian distribution centered in the minimum value observed and with standard deviation equal to the median value of the population of line-wise standard deviations.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: dataframe with missing values.</li><li><code>start_col</code>: column index to start imputing from.</li><li><code>q</code>: quantile of the minimum values to use for imputation. Default is 0.01.</li><li><code>tune_sigma</code>: coefficient that controls the sd of the MNAR distribution:               - 1 if the complete data distribution is supposed to be gaussian.               - 0 &lt; tune_sigma &lt; 1 if the complete data distribution is supposed to be                 left-censored.              Default is 1.0.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L188-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_zero!-Tuple{Matrix{Union{Missing, Float64}}}" href="#BigRiverJunbi.impute_zero!-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_zero!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_zero!(data::Matrix{Union{Missing, Float64}})</code></pre><p>Modifies the original matrix in place to replace missing elements with zero.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples and the columns are the features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L131-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_zero-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.impute_zero-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.impute_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_zero(df::DataFrame; start_col::Int64 = 1)</code></pre><p>Replaces missing elements in the specified columns with zero.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: dataframe with missing values.</li><li><code>start_col</code>: column index to start imputing from.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing
   2 │     2  missing        4  missing  missing
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.impute_zero(df)
3×5 DataFrame
 Row │ A         B         C         D         E
     │ Float64?  Float64?  Float64?  Float64?  Float64?
─────┼──────────────────────────────────────────────────
   1 │      1.0       0.0       0.0       6.0       0.0
   2 │      2.0       0.0       4.0       0.0       0.0
   3 │      3.0       0.0       5.0       7.0      10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L76-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.impute_zero-Tuple{Matrix{Union{Missing, Float64}}}" href="#BigRiverJunbi.impute_zero-Tuple{Matrix{Union{Missing, Float64}}}"><code>BigRiverJunbi.impute_zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">impute_zero(data::Matrix{Union{Missing, Float64}})</code></pre><p>Returns a matrix with missing elements replaced with zero without modifying the original matrix.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: matrix of omics value, e.g., metabolomics matrix, where the rows are the samples       and the columns are the features.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.intnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.intnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.intnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intnorm(mat::Matrix{T}; dims::Int64 = 2, lambda::Float64 = 1.0) where T &lt;: Real</code></pre><p>Total Area Normalization for each row or column. By default, it normalizes each row. This requires that the matrix has all positive values.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: The matrix to normalize.</li><li><code>dims</code>: The dimension to normalize across. Default is 2.</li><li><code>lambda</code>: The lambda parameter for the normalization. Default is 1.0.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
              7 3 5 1.5 4.5;
              8 2 7 6 9]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  1.5  4.5
 8.0  2.0  7.0  6.0  9.0

julia&gt; BigRiverJunbi.intnorm(mat)
3×5 Matrix{Float64}:
 0.05      0.1       0.2       0.3        0.35
 0.333333  0.142857  0.238095  0.0714286  0.214286
 0.25      0.0625    0.21875   0.1875     0.28125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.log2_tx-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.log2_tx-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.log2_tx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log2_tx(mat::Matrix{Float64}; eps::Float64 = 1.0)</code></pre><p>Computes logarithm base 2 on a matrix, adding a constant to all values to avoid log(0). This requires that the matrix has all positive values.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: The matrix to transform.</li><li><code>eps</code>: The constant to add to all values. Default is 1.0.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
             7 3 5 0 3.5;
             8 2 5 6 0]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  0.0  3.5
 8.0  2.0  5.0  6.0  0.0

julia&gt; BigRiverJunbi.log2_tx(mat)
3×5 Matrix{Float64}:
 0.584963  1.0      1.58496  2.0      2.16993
 3.0       2.0      2.58496  0.0      2.16993
 3.16993   1.58496  2.58496  2.80735  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/transforms.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.meancenter_tx-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:Real" href="#BigRiverJunbi.meancenter_tx-Union{Tuple{Matrix{T}}, Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:Real"><code>BigRiverJunbi.meancenter_tx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">meancenter_tx(mat::Matrix{Float64}, dims::Int64 = 1)</code></pre><p>Mean center a matrix across the specified dimension. This requires that the matrix has all positive values.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: The matrix to transform.</li><li><code>dims</code>: The dimension to mean center across. Default is 1.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
             7 3 5 0 3.5;
             8 2 5 6 0]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  0.0  3.5
 8.0  2.0  5.0  6.0  0.0

julia&gt; BigRiverJunbi.meancenter_tx(mat)
3×5 Matrix{Float64}:
 -4.66667  -1.0  -2.0   0.0   1.16667
  1.83333   1.0   1.0  -3.0   1.16667
  2.83333   0.0   1.0   3.0  -2.33333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/transforms.jl#L35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.missing_percentages-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.missing_percentages-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.missing_percentages</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">missing_percentages(df::DataFrame)</code></pre><p>Returns the percentage of missing values in each column and row, as well as the total percentage of missing values in the dataframe.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The dataframe to calculate the missing percentages for.</li></ul><p><strong>Returns</strong></p><ul><li><code>pmissing_cols::Vector{Float64}</code>: The percentage of missing values in each column.</li><li><code>pmissing_rows::Vector{Float64}</code>: The percentage of missing values in each row.</li><li><code>total_missing::Float64</code>: The total percentage of missing values in the dataframe.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing
   2 │     2  missing        4  missing  missing
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.missing_percentages(df)
([0.0, 1.0, 0.3333333333333333, 0.3333333333333333, 0.6666666666666666], [0.6, 0.6, 0.2], 0.4666666666666667)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/utils.jl#L77-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.missing_summary-Tuple{DataFrames.DataFrame}" href="#BigRiverJunbi.missing_summary-Tuple{DataFrames.DataFrame}"><code>BigRiverJunbi.missing_summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">missing_summary(df::DataFrame)</code></pre><p>Adds a row and column to the dataframe that contains the percentage of missing values in each column and row. Returns a pretty table with the percentage of missing values in the last row and column highlighted.</p><div class="admonition is-warning" id="Warning-a39cb4baa386dc16"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-a39cb4baa386dc16" title="Permalink"></a></header><div class="admonition-body"><p>This function will not preserve the type of the dataframe, as it converts everything to a string for the pretty table. It is primarily used for quick visualizations. For getting the actual missing percentages, use the <code>missing_percentages</code> function instead.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code>: The dataframe to add the missing summary to.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; df = DataFrame(A = [1, 2, 3],
                 B = [missing, missing, missing],
                 C = [missing, 4, 5],
                 D = [6, missing, 7],
                 E = [missing, missing, 10])
3×5 DataFrame
 Row │ A      B        C        D        E
     │ Int64  Missing  Int64?   Int64?   Int64?
─────┼───────────────────────────────────────────
   1 │     1  missing  missing        6  missing
   2 │     2  missing        4  missing  missing
   3 │     3  missing        5        7       10

julia&gt; BigRiverJunbi.missing_summary(df)
┌───────────────┬────────┬─────────┬─────────┬─────────┬─────────┬───────────────┐
│               │      A │       B │       C │       D │       E │ pmissing_rows │
│               │ String │  String │  String │  String │  String │        String │
├───────────────┼────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤
│             1 │      1 │ missing │ missing │       6 │ missing │           0.6 │
│             2 │      2 │ missing │       4 │ missing │ missing │           0.6 │
│             3 │      3 │ missing │       5 │       7 │      10 │           0.2 │
├───────────────┼────────┼─────────┼─────────┼─────────┼─────────┼───────────────┤
│ pmissing_cols │    0.0 │     1.0 │    0.33 │    0.33 │    0.67 │          0.47 │
└───────────────┴────────┴─────────┴─────────┴─────────┴─────────┴───────────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/utils.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.pqnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.pqnorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.pqnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pqnorm(mat::Matrix{Float64})</code></pre><p>Performs a probabilistic quotient normalization (PQN) for sample intensities. This assumes that the matrix is organized as samples x features and requires that the matrix have all positive values.</p><p><strong>Arguments</strong></p><ul><li><code>mat</code>: The matrix to normalize.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
              7 3 5 1.5 4.5;
              8 2 7 6 9]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  1.5  4.5
 8.0  2.0  7.0  6.0  9.0

julia&gt; BigRiverJunbi.pqnorm(mat)
3×5 Matrix{Float64}:
 0.05     0.1      0.2      0.3       0.35
 0.30625  0.13125  0.21875  0.065625  0.196875
 0.25     0.0625   0.21875  0.1875    0.28125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L37-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.quantilenorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#BigRiverJunbi.quantilenorm-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>BigRiverJunbi.quantilenorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quantilenorm(data::Matrix{T}) where T &lt;: Real</code></pre><p>Performs quantile normalization for sample intensities. This assumes that the matrix is organized as samples x features.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: The matrix to normalize.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = [0.5 1 2 3 3.5;
              7 3 5 1.5 4.5;
              8 2 7 6 9]
3×5 Matrix{Float64}:
 0.5  1.0  2.0  3.0  3.5
 7.0  3.0  5.0  1.5  4.5
 8.0  2.0  7.0  6.0  9.0

julia&gt; BigRiverJunbi.quantilenorm(mat)
3×5 Matrix{Float64}:
 1.7  1.7  1.7  4.3  1.7
 4.3  6.6  4.3  1.7  4.3
 6.6  4.3  6.6  6.6  6.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/normalize.jl#L83-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.substitute!-Tuple{AbstractArray{Union{Missing, Float64}}, Function}" href="#BigRiverJunbi.substitute!-Tuple{AbstractArray{Union{Missing, Float64}}, Function}"><code>BigRiverJunbi.substitute!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute!(
    data::AbstractArray{Union{Missing, Float64}},
    statistic::Function;
    dims::Union{Nothing, Int} = nothing
)</code></pre><p>Substitutes missing values with the value calculated by the statistic function along the specified dimension and modifies the original array in place.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: array of values. One example: matrix of metabolomics data, where the rows are the features and the columns are the samples.</li><li><code>statistic</code>: function that calculates the value to substitute the missing values.</li><li><code>dims</code>: dimension along which the statistic is calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BigRiverJunbi.substitute-Tuple{AbstractArray{Union{Missing, Float64}}, Function}" href="#BigRiverJunbi.substitute-Tuple{AbstractArray{Union{Missing, Float64}}, Function}"><code>BigRiverJunbi.substitute</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">substitute(
    data::AbstractArray{Union{Missing, Float64}},
    statistic::Function;
    dims::Union{Nothing, Int} = nothing
)</code></pre><p>Substitutes missing values with the value calculated by the statistic function along the specified dimension and returns a new array without modifying the original array.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: array of values. One example: matrix of metabolomics data, where the rows are the features and the columns are the samples.</li><li><code>statistic</code>: function that calculates the value to substitute the missing values.</li><li><code>dims</code>: dimension along which the statistic is calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/senresearch/BigRiverJunbi.jl/blob/78b07c5ed256843d799addd4fcb9090d2cf2de74/src/impute.jl#L1-L17">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Friday 20 June 2025 19:19">Friday 20 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
